// This file was generated by gir (https://github.com/gtk-rs/gir)
// from gir-files (https://github.com/gtk-rs/gir-files)
// DO NOT EDIT

use File;
use ffi;
use glib::GString;
use glib::object::IsA;
use glib::translate::*;
use std::fmt;

glib_wrapper! {
    pub struct Vfs(Object<ffi::GVfs, ffi::GVfsClass>);

    match fn {
        get_type => || ffi::g_vfs_get_type(),
    }
}

impl Vfs {
    pub fn get_default() -> Option<Vfs> {
        unsafe {
            from_glib_none(ffi::g_vfs_get_default())
        }
    }

    pub fn get_local() -> Option<Vfs> {
        unsafe {
            from_glib_none(ffi::g_vfs_get_local())
        }
    }
}

pub trait VfsExt: 'static {
    fn get_file_for_path(&self, path: &str) -> Option<File>;

    fn get_file_for_uri(&self, uri: &str) -> Option<File>;

    fn get_supported_uri_schemes(&self) -> Vec<GString>;

    fn is_active(&self) -> bool;

    fn parse_name(&self, parse_name: &str) -> Option<File>;

    //#[cfg(any(feature = "v2_50", feature = "dox"))]
    //fn register_uri_scheme<'a, 'b, 'c, 'd, P: Into<Option<&'a /*Unimplemented*/VfsFileLookupFunc>>, Q: Into<Option</*Unimplemented*/Fundamental: Pointer>>, R: Into<Option<&'b /*Ignored*/glib::DestroyNotify>>, S: Into<Option<&'c /*Unimplemented*/VfsFileLookupFunc>>, T: Into<Option</*Unimplemented*/Fundamental: Pointer>>, U: Into<Option<&'d /*Ignored*/glib::DestroyNotify>>>(&self, scheme: &str, uri_func: P, uri_data: Q, uri_destroy: R, parse_name_func: S, parse_name_data: T, parse_name_destroy: U) -> bool;

    #[cfg(any(feature = "v2_50", feature = "dox"))]
    fn unregister_uri_scheme(&self, scheme: &str) -> bool;
}

impl<O: IsA<Vfs>> VfsExt for O {
    fn get_file_for_path(&self, path: &str) -> Option<File> {
        unsafe {
            from_glib_full(ffi::g_vfs_get_file_for_path(self.to_glib_none().0, path.to_glib_none().0))
        }
    }

    fn get_file_for_uri(&self, uri: &str) -> Option<File> {
        unsafe {
            from_glib_full(ffi::g_vfs_get_file_for_uri(self.to_glib_none().0, uri.to_glib_none().0))
        }
    }

    fn get_supported_uri_schemes(&self) -> Vec<GString> {
        unsafe {
            FromGlibPtrContainer::from_glib_none(ffi::g_vfs_get_supported_uri_schemes(self.to_glib_none().0))
        }
    }

    fn is_active(&self) -> bool {
        unsafe {
            from_glib(ffi::g_vfs_is_active(self.to_glib_none().0))
        }
    }

    fn parse_name(&self, parse_name: &str) -> Option<File> {
        unsafe {
            from_glib_full(ffi::g_vfs_parse_name(self.to_glib_none().0, parse_name.to_glib_none().0))
        }
    }

    //#[cfg(any(feature = "v2_50", feature = "dox"))]
    //fn register_uri_scheme<'a, 'b, 'c, 'd, P: Into<Option<&'a /*Unimplemented*/VfsFileLookupFunc>>, Q: Into<Option</*Unimplemented*/Fundamental: Pointer>>, R: Into<Option<&'b /*Ignored*/glib::DestroyNotify>>, S: Into<Option<&'c /*Unimplemented*/VfsFileLookupFunc>>, T: Into<Option</*Unimplemented*/Fundamental: Pointer>>, U: Into<Option<&'d /*Ignored*/glib::DestroyNotify>>>(&self, scheme: &str, uri_func: P, uri_data: Q, uri_destroy: R, parse_name_func: S, parse_name_data: T, parse_name_destroy: U) -> bool {
    //    unsafe { TODO: call ffi::g_vfs_register_uri_scheme() }
    //}

    #[cfg(any(feature = "v2_50", feature = "dox"))]
    fn unregister_uri_scheme(&self, scheme: &str) -> bool {
        unsafe {
            from_glib(ffi::g_vfs_unregister_uri_scheme(self.to_glib_none().0, scheme.to_glib_none().0))
        }
    }
}

impl fmt::Display for Vfs {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "Vfs")
    }
}
